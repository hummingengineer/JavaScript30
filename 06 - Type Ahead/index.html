<!-- Ajax Type Ahead -->
<!-- íŠ¹ì • ë‹¨ì–´ë¥¼ í¬í•¨í•˜ëŠ” City, State ì´ë¦„ì„ ì•„ë˜ì— ë¦¬ìŠ¤íŠ¸ë¡œ ë³´ì—¬ì¤€ë‹¤ -->
<!-- Live Search ê¸°ëŠ¥ì„ êµ¬í˜„ -->

<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Type Ahead ğŸ‘€</title>
    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <form class="search-form">
      <input type="text" class="search" placeholder="City or State">
      <ul class="suggestions">
        <li>Filter for a city</li>
        <li>or a state</li>
      </ul>
    </form>
  </body>

  <script>
    const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';

    // We fetch the data which is a huge array and then once that data is back, whenever someone types into this specific box, we're going to filter that array down to a subset of all of the ones that either the city name or the state name will match.
    // First, we need an empty array to put our cities into.
    const cities = []

    // Fetch returns what's called a promise which is sort of like a something will eventually come back from this fetch.
    fetch(endpoint)
    // It's going to return to us just like a blob of data.
    // .json() method is in _proto_
    // .json() method returns another promise
      .then(blob => blob.json())
    // raw data
    // â˜…â˜…â˜…â˜…â˜… Spread into push method. Same as cities = data
      .then(data => cities.push(...data))

      function findMatches(wordToMatch, cities) {
        return cities.filter(place => {
          // 'G' is going to be global meaning it's going to look through the entire string for that specific one. ì „ì—­ ê²€ìƒ‰
          // 'I' is going to match lowercase as well as uppercase regardless of what you're searching with. ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ëŠ” ê²€ìƒ‰
          const regex = new RegExp(wordToMatch, 'gi')
          // here we need to figure out if the city on state matches what was searched
          // if it does match, then it will be true.
          // How do you put a variable into a regular expression?
          // You can't do it in this syntax here. We need to actually create a regular expression outside of it with RegExp().
          // If the city is true or the state is true, the whole thing is going to be true. ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ ì°¸ì´ë©´ filterë¡œ ë°˜í™˜ëœë‹¤.
          return place.city.match(regex) || place.state.match(regex)
        })
      }

      // Whenever I typed into, it should run this caller function find ones that match it.
      // ìš°ì„  findMatches ë¥¼ í†µí•´ ë§ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ í™•ë³´í•œë‹¤.
      // ê·¸ë¦¬ê³  í™”ë©´ì— ë¿Œë ¤ì¤„ html ì„ ë§Œë“¤ì–´ì¤€ë‹¤.
      function displayMatches() {
        const matchArray = findMatches(this.value, cities)
        // This map method is going to return an array when we really want just one string.
        // ë¦¬í„´ê°’ì´ html ë“¤ì˜ ë¦¬ìŠ¤íŠ¸ì´ê³ , ê·¸ê±¸ join ìœ¼ë¡œ í•˜ë‚˜ë¡œ ë¬¶ì–´ì¤€ë‹¤.
        const html = matchArray.map(place => {
          return `
            <li>
              <span class="name">${place.city}, ${place.state}</span>
              <span class="population">${place.population}</span>
            </li>
          `
        }).join('')
        // ìš”ì†Œ(element)ì˜ ë‚´ìš©ì„ ë³€ê²½
        // í•´ë‹¹ class ì•ˆì„ í†µì§¸ë¡œ ë°”ê¿” ë„£ì–´ì£¼ë¼ëŠ” ì˜ë¯¸
        suggestions.innerHTML = html
      }

      const searchInput = document.querySelector('.search')
      const suggestions = document.querySelector('.suggestions')

      // When the input changes, we're going to run displayMatches()
      searchInput.addEventListener('change', displayMatches)
      // Every time we key up, it's going to tell us what the person has typed into that box.
      searchInput.addEventListener('keyup', displayMatches)
  </script>

</html>
